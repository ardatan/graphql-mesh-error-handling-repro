"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processDirectives = void 0;
const graphql_1 = require("graphql");
const transport_common_1 = require("@graphql-mesh/transport-common");
const utils_1 = require("@graphql-tools/utils");
const dictionary_js_1 = require("./dictionary.js");
const discriminator_js_1 = require("./discriminator.js");
const flatten_js_1 = require("./flatten.js");
const getTypeResolverForAbstractType_js_1 = require("./getTypeResolverForAbstractType.js");
const httpOperation_js_1 = require("./httpOperation.js");
const link_js_1 = require("./link.js");
const pubsubOperation_js_1 = require("./pubsubOperation.js");
const resolveRoot_js_1 = require("./resolveRoot.js");
const resolveRootField_js_1 = require("./resolveRootField.js");
const responseMetadata_js_1 = require("./responseMetadata.js");
const scalars_js_1 = require("./scalars.js");
const typescriptAnnotations_js_1 = require("./typescriptAnnotations.js");
function processDirectives(schema, { globalFetch, logger, pubsub, ...extraGlobalOptions } = {}) {
    const nonExecutableObjMapScalar = schema.getType('ObjMap');
    if (nonExecutableObjMapScalar && (0, graphql_1.isScalarType)(nonExecutableObjMapScalar)) {
        (0, scalars_js_1.addExecutionLogicToScalar)(nonExecutableObjMapScalar, transport_common_1.ObjMapScalar);
    }
    const transportDirectives = (0, utils_1.getDirective)(schema, schema, 'transport');
    const currDirective = transportDirectives?.[0];
    const globalOptions = {
        endpoint: currDirective?.location,
        operationHeaders: currDirective?.headers,
        queryParams: currDirective?.queryParams,
        queryStringOptions: currDirective?.queryStringOptions,
        ...extraGlobalOptions,
    };
    if (typeof globalOptions.operationHeaders === 'string') {
        globalOptions.operationHeaders = JSON.parse(globalOptions.operationHeaders);
    }
    if (typeof globalOptions.queryParams === 'string') {
        globalOptions.queryParams = JSON.parse(globalOptions.queryParams);
    }
    const typeMap = schema.getTypeMap();
    for (const typeName in typeMap) {
        const type = typeMap[typeName];
        const exampleAnnotations = (0, utils_1.getDirective)(schema, type, 'example');
        if (exampleAnnotations?.length) {
            const examples = [];
            for (const exampleAnnotation of exampleAnnotations) {
                if (exampleAnnotation?.value) {
                    examples.push(exampleAnnotation.value);
                }
            }
            type.extensions = type.extensions || {};
            type.extensions.examples = examples;
        }
        if ((0, graphql_1.isScalarType)(type)) {
            (0, scalars_js_1.processScalarType)(type);
        }
        if ((0, graphql_1.isInterfaceType)(type)) {
            const directiveAnnotations = (0, utils_1.getDirectives)(schema, type);
            for (const directiveAnnotation of directiveAnnotations) {
                switch (directiveAnnotation.name) {
                    case 'discriminator':
                        (0, discriminator_js_1.processDiscriminatorAnnotations)({
                            interfaceType: type,
                            discriminatorFieldName: directiveAnnotation.args.field,
                        });
                        break;
                }
            }
        }
        if ((0, graphql_1.isUnionType)(type)) {
            const directiveAnnotations = (0, utils_1.getDirectives)(schema, type);
            let statusCodeTypeNameIndexMap;
            let discriminatorField;
            let discriminatorMapping;
            for (const directiveAnnotation of directiveAnnotations) {
                switch (directiveAnnotation.name) {
                    case 'statusCodeTypeName':
                        statusCodeTypeNameIndexMap = statusCodeTypeNameIndexMap || {};
                        statusCodeTypeNameIndexMap[directiveAnnotation.args.statusCode] =
                            directiveAnnotation.args.typeName;
                        break;
                    case 'discriminator':
                        discriminatorField = directiveAnnotation.args.field;
                        discriminatorMapping = directiveAnnotation.args.mapping;
                        break;
                }
            }
            type.resolveType = (0, getTypeResolverForAbstractType_js_1.getTypeResolverForAbstractType)({
                possibleTypes: type.getTypes(),
                discriminatorField,
                discriminatorMapping,
                statusCodeTypeNameMap: statusCodeTypeNameIndexMap,
            });
        }
        if ((0, graphql_1.isEnumType)(type)) {
            const directiveAnnotations = (0, utils_1.getDirectives)(schema, type);
            for (const directiveAnnotation of directiveAnnotations) {
                switch (directiveAnnotation.name) {
                    case 'typescript':
                        (0, typescriptAnnotations_js_1.processTypeScriptAnnotations)(type, directiveAnnotation.args.type);
                        break;
                }
            }
            const enumValues = type.getValues();
            for (const enumValue of enumValues) {
                const directiveAnnotations = (0, utils_1.getDirectives)(schema, enumValue);
                for (const directiveAnnotation of directiveAnnotations) {
                    switch (directiveAnnotation.name) {
                        case 'enum': {
                            const realValue = JSON.parse(directiveAnnotation.args.value);
                            enumValue.value = realValue;
                            type._valueLookup.set(realValue, enumValue);
                            break;
                        }
                    }
                }
            }
        }
        if ('getFields' in type) {
            const fields = type.getFields();
            for (const fieldName in fields) {
                const field = fields[fieldName];
                const directiveAnnotations = (0, utils_1.getDirectives)(schema, field);
                for (const directiveAnnotation of directiveAnnotations) {
                    switch (directiveAnnotation.name) {
                        case 'resolveRoot':
                            (0, resolveRoot_js_1.processResolveRootAnnotations)(field);
                            break;
                        case 'resolveRootField':
                            (0, resolveRootField_js_1.processResolveRootFieldAnnotations)(field, directiveAnnotation.args.field);
                            break;
                        case 'flatten':
                            (0, flatten_js_1.processFlattenAnnotations)(field);
                            break;
                        case 'pubsubOperation':
                            (0, pubsubOperation_js_1.processPubSubOperationAnnotations)({
                                field: field,
                                pubsubTopic: directiveAnnotation.args.pubsubTopic,
                                globalPubsub: pubsub,
                                logger,
                            });
                            break;
                        case 'httpOperation':
                            (0, httpOperation_js_1.addHTTPRootFieldResolver)(schema, field, logger, globalFetch, 
                            // TODO: Fix JSON parsing here for queryParams and headers
                            {
                                sourceName: directiveAnnotation.args.sourceName,
                                endpoint: directiveAnnotation.args.endpoint,
                                path: directiveAnnotation.args.path,
                                httpMethod: directiveAnnotation.args.httpMethod,
                                operationSpecificHeaders: typeof directiveAnnotation.args.operationSpecificHeaders === 'string'
                                    ? JSON.parse(directiveAnnotation.args.operationSpecificHeaders)
                                    : directiveAnnotation.args.operationSpecificHeaders,
                                isBinary: directiveAnnotation.args.isBinary,
                                requestBaseBody: typeof directiveAnnotation.args.requestBaseBody === 'string'
                                    ? JSON.parse(directiveAnnotation.args.requestBaseBody)
                                    : directiveAnnotation.args.requestBaseBody,
                                queryParamArgMap: typeof directiveAnnotation.args.queryParamArgMap === 'string'
                                    ? JSON.parse(directiveAnnotation.args.queryParamArgMap)
                                    : directiveAnnotation.args.queryParamArgMap,
                                queryStringOptionsByParam: typeof directiveAnnotation.args.queryStringOptionsByParam === 'string'
                                    ? JSON.parse(directiveAnnotation.args.queryStringOptionsByParam)
                                    : directiveAnnotation.args.queryStringOptionsByParam,
                                jsonApiFields: directiveAnnotation.args.jsonApiFields,
                            }, globalOptions);
                            break;
                        case 'responseMetadata':
                            (0, responseMetadata_js_1.processResponseMetadataAnnotations)(field);
                            break;
                        case 'link':
                            (0, link_js_1.processLinkFieldAnnotations)(field, directiveAnnotation.args.defaultRootType, directiveAnnotation.args.defaultField);
                            break;
                        case 'dictionary':
                            (0, dictionary_js_1.processDictionaryDirective)(fields, field);
                    }
                }
            }
        }
    }
    return schema;
}
exports.processDirectives = processDirectives;
