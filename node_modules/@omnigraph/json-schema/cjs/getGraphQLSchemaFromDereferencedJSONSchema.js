"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGraphQLSchemaFromDereferencedJSONSchema = void 0;
const graphql_1 = require("graphql");
const graphql_compose_1 = require("graphql-compose");
const addExecutionLogicToComposer_js_1 = require("./addExecutionLogicToComposer.js");
const getComposerFromJSONSchema_js_1 = require("./getComposerFromJSONSchema.js");
async function getGraphQLSchemaFromDereferencedJSONSchema(subgraphName, opts) {
    const { fullyDeferencedSchema, logger, operations, operationHeaders, endpoint, queryParams, queryStringOptions, handlerName = 'rest', } = opts;
    logger.debug(`Generating GraphQL Schema from the bundled JSON Schema`);
    const visitorResult = await (0, getComposerFromJSONSchema_js_1.getComposerFromJSONSchema)({
        subgraphName,
        schema: fullyDeferencedSchema,
        logger: logger.child('getComposerFromJSONSchema'),
        getScalarForFormat: opts.getScalarForFormat,
    });
    const schemaComposerWithoutExecutionLogic = visitorResult.output;
    if (!(schemaComposerWithoutExecutionLogic instanceof graphql_compose_1.SchemaComposer)) {
        throw new Error('The visitor result should be a SchemaComposer instance.');
    }
    // graphql-compose doesn't add @defer and @stream to the schema
    for (const directive of graphql_1.specifiedDirectives) {
        schemaComposerWithoutExecutionLogic.addDirective(directive);
    }
    return (0, addExecutionLogicToComposer_js_1.addExecutionDirectivesToComposer)(subgraphName, {
        schemaComposer: schemaComposerWithoutExecutionLogic,
        logger,
        operations,
        operationHeaders,
        endpoint,
        queryParams,
        queryStringOptions,
        handlerName,
    });
}
exports.getGraphQLSchemaFromDereferencedJSONSchema = getGraphQLSchemaFromDereferencedJSONSchema;
